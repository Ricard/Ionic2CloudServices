import { IConfig, IEventEmitter, ILogger, IDeploy, DeployWatchOptions, DeployDownloadOptions, DeployExtractOptions, DeployUpdateOptions, DeployDependencies, DeployOptions } from '../definitions';
export declare class Deploy implements IDeploy {
    config: IConfig;
    emitter: IEventEmitter;
    logger: ILogger;
    private _plugin;
    private _channelTag;
    private _checkTimeout;
    constructor(deps: DeployDependencies, options?: DeployOptions);
    /**
     * Fetch the Deploy Plugin
     *
     * If the plugin has not been set yet, attempt to fetch it, otherwise log
     * a message.
     *
     * @return {IonicDeploy} Returns the plugin or false
     */
    _getPlugin(): any;
    /**
     * Check for updates
     *
     * @return {Promise} Will resolve with true if an update is available, false otherwise. A string or
     *   error will be passed to reject() in the event of a failure.
     */
    check(): Promise<boolean>;
    /**
     * Download and available update
     *
     * This should be used in conjunction with extract()
     * @return {Promise} The promise which will resolve with true/false.
     */
    download(options?: DeployDownloadOptions): Promise<boolean>;
    /**
     * Extract the last downloaded update
     *
     * This should be called after a download() successfully resolves.
     * @return {Promise} The promise which will resolve with true/false.
     */
    extract(options?: DeployExtractOptions): Promise<boolean>;
    /**
     * Load the latest deployed version
     * This is only necessary to call if you have manually downloaded and extracted
     * an update and wish to reload the app with the latest deploy. The latest deploy
     * will automatically be loaded when the app is started.
     *
     * @return {void}
     */
    load(): void;
    /**
     * Watch constantly checks for updates, and triggers an event when one is ready.
     */
    watch(options?: DeployWatchOptions): void;
    /**
     * Stop automatically looking for updates
     */
    unwatch(): void;
    /**
     * Information about the current deploy
     *
     * @return {Promise} The resolver will be passed an object that has key/value
     *    pairs pertaining to the currently deployed update.
     */
    info(): Promise<any>;
    /**
     * List the Deploy versions that have been installed on this device
     *
     * @return {Promise} The resolver will be passed an array of deploy uuids
     */
    getVersions(): Promise<any>;
    /**
     * Remove an installed deploy on this device
     *
     * @param {string} uuid The deploy uuid you wish to remove from the device
     * @return {Promise} Standard resolve/reject resolution
     */
    deleteVersion(uuid: string): Promise<any>;
    /**
     * Fetches the metadata for a given deploy uuid. If no uuid is given, it will attempt
     * to grab the metadata for the most recently known update version.
     *
     * @param {string} uuid The deploy uuid you wish to grab metadata for, can be left blank to grab latest known update metadata
     * @return {Promise} Standard resolve/reject resolution
     */
    getMetadata(uuid: string): Promise<any>;
    /**
     * Set the deploy channel that should be checked for updatse
     * See http://docs.ionic.io/docs/deploy-channels for more information
     *
     * @param {string} channelTag The channel tag to use
     */
    setChannel(channelTag: string): void;
    /**
     * Update app with the latest deploy
     */
    update(options?: DeployUpdateOptions): Promise<boolean>;
}
